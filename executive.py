# -*- coding: utf-8 -*-
"""executive.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-gvRCiRWXcZUlwEPOVd-G_yNZ5q_q3Kv
"""

# executive.py
from langgraph.graph import StateGraph, END

# Import tools
from tools.code_search_tool import code_search_tool
from tools.code_generator_tool import code_generator_tool
from tools.linter_tool import linter_tool
from tools.test_generator_tool import test_generator_tool
from tools.test_runner_tool import test_runner_tool
from tools.debug_tool import debug_tool

# ---- Constants ----
MAX_ITERATIONS = 5

# ---- Initial State ----
state = {
    "query": None,   # dynamically set from main.py
    "context": None,
    "migrated_code": None,
    "tests": None,
    "lint_errors": None,
    "test_results": None,
    "errors": None,
    "iteration": 0,
    "stopped": False,
}

# ---- Nodes ----
def search_code(s):
    print("\n[Executive] Searching code context...")
    context = code_search_tool(s["query"])
    if not context or context == "No relevant code found.":
        print("[Executive] No relevant context found ❌")
        s["stopped"] = True
        return s
    s["context"] = context
    return s

def migrate_code(s):
    print("\n[Executive] Migrating code...")
    s["migrated_code"] = code_generator_tool(s["context"])
    return s

def lint_code(s):
    print("\n[Executive] Running linter...")
    if not s["migrated_code"]:
        print("[Executive] No code to lint ❌")
        s["stopped"] = True
        return s

    passed, error = linter_tool(s["migrated_code"])
    if not passed:
        print(f"[Executive] Lint failed: {error}")
        s["lint_errors"] = error
        s["errors"] = error
    else:
        print("[Executive] Lint passed ✅")
        s["lint_errors"] = None
    return s

def generate_tests(s):
    print("\n[Executive] Generating tests...")
    if not s["migrated_code"]:
        print("[Executive] No code to generate tests for ❌")
        s["stopped"] = True
        return s
    s["tests"] = test_generator_tool(s["context"], s["migrated_code"])
    if s.get("tests"):
        with open("generated_tests.py", "w") as f:
            f.write(s["tests"])
        print("[Executive] Generated tests saved locally as generated_tests.py ✅")
    return s

def run_tests(s):
    print("\n[Executive] Running tests...")
    if not s["tests"] or not s["migrated_code"]:
        print("[Executive] Missing tests or code ❌")
        s["stopped"] = True
        return s

    passed, error = test_runner_tool(s["tests"], s["migrated_code"])
    if not passed:
        print(f"[Executive] Tests failed ❌: {error}")
        s["test_results"] = "fail"
        s["errors"] = error
    else:
        print("[Executive] All tests passed ✅")
        s["test_results"] = "pass"
        s["errors"] = None
    return s

def debug_code(s):
    print("\n[Executive] Debugging code...")

    if not s.get("errors"):
        print("[Executive] No errors to debug ❌")
        s["stopped"] = True
        return s

    iteration = s.get("iteration", 0)
    if iteration >= MAX_ITERATIONS:
        print(f"[Executive] Safety cutoff reached ({MAX_ITERATIONS} attempts). Stopping.")
        s["stopped"] = True
        return s

    updated_code = debug_tool(s["errors"], s["migrated_code"])
    print("[Debug] Debugged code preview:\n", updated_code)
    s["migrated_code"] = updated_code
    s["iteration"] = iteration + 1

    # After debugging test failures, regenerate tests to ensure coverage
    if s.get("test_results") == "fail":
        s = generate_tests(s)
    return s

def save_code(s):
    print("\n[Executive] Saving final code + tests...")
    if s.get("migrated_code"):
        with open("migrated_code.py", "w") as f:
            f.write(s["migrated_code"])
    if s.get("tests"):
        with open("generated_tests.py", "w") as f:
            f.write(s["tests"])
    print("[Executive] Code and tests saved to disk ✅")
    return s

def stop_execution(s):
    print("\n[Executive] Workflow stopped manually or safety cutoff reached.")
    return s

# ---- Graph ----
builder = StateGraph(dict)

# Add nodes
builder.add_node("search", search_code)
builder.add_node("migrate", migrate_code)
builder.add_node("lint", lint_code)
builder.add_node("generate_tests", generate_tests)
builder.add_node("run_tests", run_tests)
builder.add_node("debug", debug_code)
builder.add_node("save", save_code)
builder.add_node("stop", stop_execution)

# Set entry point
builder.set_entry_point("search")

# --- Main flow ---
builder.add_edge("search", "migrate")
builder.add_edge("migrate", "lint")

# --- Lint phase ---
builder.add_conditional_edges(
    "lint",
    lambda s: "fail" if s["lint_errors"] else "pass",
    {"fail": "debug", "pass": "generate_tests"}
)

# --- Tests phase ---
builder.add_edge("generate_tests", "run_tests")
builder.add_conditional_edges(
    "run_tests",
    lambda s: "fail" if s["test_results"] == "fail" else "pass",
    {"fail": "debug", "pass": "save"}
)

# --- Debug phase ---
builder.add_conditional_edges(
    "debug",
    lambda s: (
        "stop" if s["stopped"]
        else "lint" if s.get("lint_errors")
        else "run_tests"
    ),
    {"stop": "stop", "lint": "lint", "run_tests": "run_tests"}
)

# Endpoints
builder.add_edge("save", END)
builder.add_edge("stop", END)

# Compile graph
graph = builder.compile()